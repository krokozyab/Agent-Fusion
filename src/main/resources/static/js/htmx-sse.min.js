/*
HTMX SSE Extension - Handles Server-Sent Events with out-of-band swaps
Completely bypasses HTMX's built-in SSE handler to prevent null reference errors

CRITICAL: Error handlers must be installed SYNCHRONOUSLY before HTMX loads
This script runs in <head> before HTMX, so we set up protections immediately
*/

// Patch console.error to suppress expected HTMX errors
var htmxSSEOriginalConsoleError = console.error;
console.error = function() {
  var msg = arguments[0] ? String(arguments[0]) : '';
  if (msg.indexOf('Cannot read properties') !== -1 || msg.indexOf('dispatchEvent') !== -1) {
    console.warn("Suppressed expected HTMX error:", msg);
    return; // Don't call original
  }
  return htmxSSEOriginalConsoleError.apply(console, arguments);
};

// Install global error handler IMMEDIATELY before anything else runs
var htmxSSEOriginalErrorHandler = window.onerror;
window.onerror = function(msg, url, lineNo, columnNo, error) {
  // Catch all null reference errors - HTMX will trigger them
  if (msg && typeof msg === 'string' && msg.indexOf('Cannot read properties of null') !== -1) {
    console.warn("Suppressed null reference error from HTMX:", msg);
    return true; // Suppress the error
  }
  // Call original error handler if it exists
  if (typeof htmxSSEOriginalErrorHandler === 'function') {
    return htmxSSEOriginalErrorHandler(msg, url, lineNo, columnNo, error);
  }
  return false;
};

// Install unhandled rejection handler IMMEDIATELY
window.addEventListener('unhandledrejection', function(event) {
  if (event.reason && event.reason.message && event.reason.message.indexOf('null') !== -1) {
    console.warn("Suppressed unhandled promise rejection:", event.reason.message);
    event.preventDefault();
  }
}, true); // Use capture phase to intercept early

// Wrap Element.prototype.dispatchEvent IMMEDIATELY before HTMX loads
var htmxSSEOriginalDispatchEvent = Element.prototype.dispatchEvent;
Element.prototype.dispatchEvent = function(event) {
  try {
    return htmxSSEOriginalDispatchEvent.call(this, event);
  } catch (e) {
    console.warn("Suppressed dispatchEvent error:", e.message);
    return false;
  }
};

(function() {
  'use strict';

  function setupSSEOverrides() {
    console.log("Setting up SSE overrides");
    var htmx = window.htmx;
    if (!htmx) {
      console.warn("HTMX not available for override setup");
      return;
    }

    // Override the internal trigger function at the class/prototype level
    if (htmx.ajax && htmx.ajax._) {
      // HTMX 1.x structure
      var api = htmx.ajax._;
      if (api.trigger) {
        console.warn("Found htmx.ajax._.trigger, overriding");
        var originalTrigger = api.trigger;
        api.trigger = function(elt, event, detail) {
          if (!elt) {
            console.warn("HTMX internal trigger called with null element - BLOCKING");
            return;
          }
          return originalTrigger.call(this, elt, event, detail);
        };
      }
    }
  }

  // Wait for HTMX to be available
  function initSSEExtension() {
    if (!window.htmx) {
      console.debug("HTMX not ready yet, retrying in 100ms...");
      setTimeout(initSSEExtension, 100);
      return;
    }

    console.log("HTMX SSE extension loaded and registered");

    var htmx = window.htmx;

    // Wrap htmx.find to return null safely
    if (htmx.find) {
      var originalFind = htmx.find;
      htmx.find = function(selector) {
        try {
          return originalFind.call(htmx, selector);
        } catch (e) {
          console.warn("HTMX find failed for selector:", selector, "error:", e.message);
          return null;
        }
      };
    }

    // Override HTMX's createEventSource to prevent it from trying to manage SSE
    // This stops HTMX's built-in SSE handler from interfering
    if (htmx.createEventSource) {
      var originalCreateEventSource = htmx.createEventSource;
      htmx.createEventSource = function(url) {
        console.log("HTMX tried to create EventSource for:", url, "- BLOCKING to prevent conflicts");
        // Return a dummy object that won't cause errors
        return {
          addEventListener: function() {},
          removeEventListener: function() {},
          close: function() {}
        };
      };
    }

    // Also override the public trigger function to catch null targets early
    if (htmx.trigger) {
      var originalTrigger = htmx.trigger;
      htmx.trigger = function(elt, event, detail) {
        // Handle selector strings by finding the element
        if (typeof elt === 'string') {
          elt = document.querySelector(elt);
        }
        if (!elt) {
          console.warn("HTMX trigger called with null/missing element for event:", event, "- BLOCKING to prevent error");
          return false;
        }
        try {
          return originalTrigger.call(htmx, elt, event, detail);
        } catch (e) {
          if (e.message && e.message.indexOf('Cannot read properties of null') !== -1) {
            console.warn("Caught trigger error:", e.message);
            return false;
          }
          throw e;
        }
      };
    }

    // Override internal trigger through event processing
    var originalProcessNode = htmx.processNode;
    if (originalProcessNode) {
      htmx.processNode = function(node) {
        try {
          return originalProcessNode.call(this, node);
        } catch (e) {
          if (e.message && e.message.indexOf("null") !== -1 && e.message.indexOf("dispatchEvent") !== -1) {
            console.warn("Caught null dispatchEvent error in processNode:", e);
            return;
          }
          throw e;
        }
      };
    }

    // Register this as an HTMX extension (for naming purposes)
    htmx.defineExtension('sse', {
      init: function(api) {
        console.log("SSE extension initialized by HTMX");
      }
    });

    // Global handler for all HTMX SSE events - intercept and prevent HTMX processing
    document.addEventListener("htmx:sseBeforeMessage", function(evt) {
      console.log("htmx:sseBeforeMessage intercepted - lastEvent:", evt.detail ? evt.detail.lastEvent : "unknown");
      // Stop HTMX from processing this
      evt.preventDefault();
      evt.stopImmediatePropagation();
    }, true); // Capture phase to intercept early

    // Our custom handler for SSE messages - we do the DOM swaps ourselves
    document.addEventListener("htmx:sseMessage", function(evt) {
      try {
        if (!evt.detail) {
          console.log("No detail in SSE message");
          return;
        }

        var detail = evt.detail;
        var eventName = detail.lastEvent || detail.eventType;

        console.log("SSE Message received - lastEvent:", detail.lastEvent, "eventType:", detail.eventType, "data length:", detail.data ? detail.data.length : 0);

        if (!eventName) {
          console.log("No event name found in SSE message");
          return;
        }

        // Find target element with matching sse-swap attribute
        var target = document.querySelector('[sse-swap="' + eventName + '"]');

        if (!target) {
          var availableSwaps = [].slice.call(document.querySelectorAll("[sse-swap]")).map(function(el) {
            return el.getAttribute("sse-swap");
          });
          console.log("No swap target found for event:", eventName, "available targets:", availableSwaps);
          return;
        }

        console.log("Found swap target for event:", eventName, "element:", target.id || target.className);

        // Parse the HTML fragment from the SSE data
        var template = document.createElement("template");
        var htmlString = (detail.data || "").trim();
        template.innerHTML = htmlString;
        var newContent = template.content.firstElementChild;

        if (!newContent) {
          console.error("Failed to parse HTML fragment");
          return;
        }

        console.log("Performing outerHTML swap");

        if (!newContent.hasAttribute("sse-swap")) {
          newContent.setAttribute("sse-swap", eventName);
        }

        // Perform direct DOM replacement
        var inserted = newContent.cloneNode(true);
        target.replaceWith(inserted);

        if (window.htmx && typeof window.htmx.process === "function") {
          window.htmx.process(inserted);
        }

        console.log("Swap completed successfully");

      } catch (e) {
        console.error("Error processing SSE message:", e, e.stack);
      }
    }, false);

    // Manually create and connect EventSource for our custom SSE handling
    // Wait for body element to be available since this script runs in head before body is parsed
    var indexSseRetryDelay = 1000;
    function initEventSource(force) {
      console.log('[initEventSource] Called with force=' + force);
      // If force=true is passed, it means a new operation is starting.
      // However, we should NOT close an existing active connection since events may
      // arrive immediately after the button is clicked. The existing connection will
      // continue to receive those events.

      if (window.__indexSSEInitializing) {
        console.log('[initEventSource] Already initializing, returning early');
        return;
      }
      window.__indexSSEInitializing = true;
      console.log('[initEventSource] Set __indexSSEInitializing=true');

      var ensureBody = function(callback) {
        var body = document.body;
        console.log('[initEventSource] ensureBody: body element exists?', !!body);
        if (!body) {
          console.debug("Body element not ready yet, retrying in 100ms...");
          setTimeout(function() {
            ensureBody(callback);
          }, 100);
          return;
        }
        callback(body);
      };

      ensureBody(function(body) {
        console.log('[initEventSource] Body element ready, checking for data-sse-url');
        window.__indexSSEInitializing = false;

        var sseUrl = body.getAttribute('data-sse-url');
        console.log('[initEventSource] data-sse-url value:', sseUrl);
        if (!sseUrl) {
          console.log("No data-sse-url found on body element");
          return;
        }

        // If we already have an active connection to the same URL, keep using it
        // This is important because events may arrive immediately after a button click
        // and we don't want to miss them by closing/reopening the connection
        if (window.__indexSSE && window.__indexSSE.url === sseUrl) {
          var readyState = window.__indexSSE.readyState;
          console.log('[initEventSource] Existing SSE connection found, readyState:', readyState, '(CONNECTING=0, OPEN=1, CLOSED=2)');
          if (readyState === EventSource.OPEN || readyState === EventSource.CONNECTING) {
            console.log("SSE connection already active, reusing existing connection");
            return;
          }
        }

        // Only close and reconnect if the previous connection is closed or doesn't exist
        if (window.__indexSSE) {
          console.log('[initEventSource] Closing previous EventSource');
          try {
            window.__indexSSE.close();
          } catch (e) {
            console.warn("Failed to close previous EventSource:", e.message);
          }
          window.__indexSSE = null;
        }

        console.log("[initEventSource] Found SSE URL:", sseUrl);
        console.log('[initEventSource] Creating new EventSource...');
        var eventSource = new EventSource(sseUrl, { withCredentials: true });
        window.__indexSSE = eventSource;
        console.log("[initEventSource] Created EventSource for:", sseUrl, "readyState:", eventSource.readyState);

        eventSource.addEventListener('open', function() {
          console.log("EventSource connection opened");
          indexSseRetryDelay = 1000;
        });

        var dispatchMessage = function(lastEventName, data) {
          var detail = {
            data: data,
            lastEvent: lastEventName
          };
          var beforeEvent = new CustomEvent('htmx:sseBeforeMessage', {
            detail: detail,
            bubbles: true,
            cancelable: true
          });
          document.dispatchEvent(beforeEvent);

          var messageEvent = new CustomEvent('htmx:sseMessage', {
            detail: detail,
            bubbles: true
          });
          document.dispatchEvent(messageEvent);
        };

        eventSource.addEventListener('indexProgress', function(event) {
          dispatchMessage('indexProgress', event.data);
        });

        eventSource.addEventListener('indexSummary', function(event) {
          dispatchMessage('indexSummary', event.data);
        });

        eventSource.addEventListener('connected', function(event) {
          dispatchMessage('connected', event.data);
        });

        eventSource.onerror = function(error) {
          console.error("EventSource error - readyState:", eventSource.readyState, "error:", error);
          try {
            eventSource.close();
          } catch (e) {
            console.warn("Error closing EventSource:", e.message);
          }
          window.__indexSSE = null;
          var delay = indexSseRetryDelay;
          indexSseRetryDelay = Math.min(indexSseRetryDelay * 2, 10000);
          console.log("Attempting to reconnect SSE in", delay, "ms");
          setTimeout(initEventSource, delay);
        };

        window.addEventListener('beforeunload', function() {
          if (window.__indexSSE) {
            try {
              window.__indexSSE.close();
            } catch (e) {
              console.warn("Error closing EventSource on unload:", e.message);
            }
            window.__indexSSE = null;
          }
        }, { once: true });
      });
    }

    console.log('[htmx-sse] Calling initial initEventSource()');
    initEventSource();
    console.log('[htmx-sse] Setting window.__initIndexSSE = initEventSource');
    window.__initIndexSSE = initEventSource;
    console.log('[htmx-sse] window.__initIndexSSE is now:', typeof window.__initIndexSSE);

    document.addEventListener('htmx:afterSettle', function() {
      console.log('[htmx-sse] htmx:afterSettle event fired, calling initEventSource()');
      initEventSource();
    });
    document.addEventListener('htmx:afterSwap', function(evt) {
      if (evt && evt.target && evt.target.getAttribute && evt.target.getAttribute('id') === 'index-status-container') {
        console.log('[htmx-sse] htmx:afterSwap for index-status-container, calling initEventSource(true)');
        initEventSource(true);
        return;
      }

      if (evt && evt.target && evt.target.classList && evt.target.classList.contains('modal__body')) {
        var hasMermaid = evt.target.querySelector('.mermaid') !== null;
        if (hasMermaid) {
          console.log('[htmx-sse] htmx:afterSwap detected mermaid in modal, scheduling rerender');
          setTimeout(function() {
            try {
              if (window.mermaid && typeof window.mermaid.run === 'function') {
                window.mermaid.run({
                  querySelector: '.mermaid'
                }).catch(function(error) {
                  console.warn('Mermaid rerender failed:', error);
                });
              }
            } catch (error) {
              console.warn('Mermaid rerender threw:', error);
            }
          }, 120);
        }
      }
    });
  }

  // Start initialization when script loads
  initSSEExtension();
})();
