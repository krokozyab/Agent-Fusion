/*
HTMX SSE Extension - Handles Server-Sent Events with out-of-band swaps
Completely bypasses HTMX's built-in SSE handler to prevent null reference errors

CRITICAL: Error handlers must be installed SYNCHRONOUSLY before HTMX loads
This script runs in <head> before HTMX, so we set up protections immediately
*/

// Install global error handler IMMEDIATELY before anything else runs
var htmxSSEOriginalErrorHandler = window.onerror;
window.onerror = function(msg, url, lineNo, columnNo, error) {
  // Catch all null reference errors - HTMX will trigger them
  if (msg && typeof msg === 'string' && msg.indexOf('Cannot read properties of null') !== -1) {
    console.warn("Suppressed null reference error from HTMX:", msg);
    return true; // Suppress the error
  }
  // Call original error handler if it exists
  if (typeof htmxSSEOriginalErrorHandler === 'function') {
    return htmxSSEOriginalErrorHandler(msg, url, lineNo, columnNo, error);
  }
  return false;
};

// Install unhandled rejection handler IMMEDIATELY
window.addEventListener('unhandledrejection', function(event) {
  if (event.reason && event.reason.message && event.reason.message.indexOf('null') !== -1) {
    console.warn("Suppressed unhandled promise rejection:", event.reason.message);
    event.preventDefault();
  }
}, true); // Use capture phase to intercept early

// Wrap Element.prototype.dispatchEvent IMMEDIATELY before HTMX loads
var htmxSSEOriginalDispatchEvent = Element.prototype.dispatchEvent;
Element.prototype.dispatchEvent = function(event) {
  try {
    return htmxSSEOriginalDispatchEvent.call(this, event);
  } catch (e) {
    console.warn("Suppressed dispatchEvent error:", e.message);
    return false;
  }
};

(function() {
  'use strict';

  function setupSSEOverrides() {
    console.log("Setting up SSE overrides");
    var htmx = window.htmx;
    if (!htmx) {
      console.warn("HTMX not available for override setup");
      return;
    }

    // Override the internal trigger function at the class/prototype level
    if (htmx.ajax && htmx.ajax._) {
      // HTMX 1.x structure
      var api = htmx.ajax._;
      if (api.trigger) {
        console.warn("Found htmx.ajax._.trigger, overriding");
        var originalTrigger = api.trigger;
        api.trigger = function(elt, event, detail) {
          if (!elt) {
            console.warn("HTMX internal trigger called with null element - BLOCKING");
            return;
          }
          return originalTrigger.call(this, elt, event, detail);
        };
      }
    }
  }

  // Wait for HTMX to be available
  function initSSEExtension() {
    if (!window.htmx) {
      console.debug("HTMX not ready yet, retrying in 100ms...");
      setTimeout(initSSEExtension, 100);
      return;
    }

    console.log("HTMX SSE extension loaded and registered");

    var htmx = window.htmx;

    // Wrap htmx.find to return null safely
    if (htmx.find) {
      var originalFind = htmx.find;
      htmx.find = function(selector) {
        try {
          return originalFind.call(htmx, selector);
        } catch (e) {
          console.warn("HTMX find failed for selector:", selector, "error:", e.message);
          return null;
        }
      };
    }

    // Override HTMX's createEventSource to prevent it from trying to manage SSE
    // This stops HTMX's built-in SSE handler from interfering
    if (htmx.createEventSource) {
      var originalCreateEventSource = htmx.createEventSource;
      htmx.createEventSource = function(url) {
        console.log("HTMX tried to create EventSource for:", url, "- BLOCKING to prevent conflicts");
        // Return a dummy object that won't cause errors
        return {
          addEventListener: function() {},
          removeEventListener: function() {},
          close: function() {}
        };
      };
    }

    // Also override the public trigger function to catch null targets early
    if (htmx.trigger) {
      var originalTrigger = htmx.trigger;
      htmx.trigger = function(elt, event, detail) {
        // Handle selector strings by finding the element
        if (typeof elt === 'string') {
          elt = document.querySelector(elt);
        }
        if (!elt) {
          console.warn("HTMX trigger called with null/missing element for event:", event, "- BLOCKING to prevent error");
          return false;
        }
        try {
          return originalTrigger.call(htmx, elt, event, detail);
        } catch (e) {
          if (e.message && e.message.indexOf('Cannot read properties of null') !== -1) {
            console.warn("Caught trigger error:", e.message);
            return false;
          }
          throw e;
        }
      };
    }

    // Override internal trigger through event processing
    var originalProcessNode = htmx.processNode;
    if (originalProcessNode) {
      htmx.processNode = function(node) {
        try {
          return originalProcessNode.call(this, node);
        } catch (e) {
          if (e.message && e.message.indexOf("null") !== -1 && e.message.indexOf("dispatchEvent") !== -1) {
            console.warn("Caught null dispatchEvent error in processNode:", e);
            return;
          }
          throw e;
        }
      };
    }

    // Register this as an HTMX extension (for naming purposes)
    htmx.defineExtension('sse', {
      init: function(api) {
        console.log("SSE extension initialized by HTMX");
      }
    });

    // Global handler for all HTMX SSE events - intercept and prevent HTMX processing
    document.addEventListener("htmx:sseBeforeMessage", function(evt) {
      console.log("htmx:sseBeforeMessage intercepted - lastEvent:", evt.detail ? evt.detail.lastEvent : "unknown");
      // Stop HTMX from processing this
      evt.preventDefault();
      evt.stopImmediatePropagation();
    }, true); // Capture phase to intercept early

    // Our custom handler for SSE messages - we do the DOM swaps ourselves
    document.addEventListener("htmx:sseMessage", function(evt) {
      try {
        if (!evt.detail) {
          console.log("No detail in SSE message");
          return;
        }

        var detail = evt.detail;
        var eventName = detail.lastEvent || detail.eventType;

        console.log("SSE Message received - lastEvent:", detail.lastEvent, "eventType:", detail.eventType, "data length:", detail.data ? detail.data.length : 0);

        if (!eventName) {
          console.log("No event name found in SSE message");
          return;
        }

        // Find target element with matching sse-swap attribute
        var target = document.querySelector('[sse-swap="' + eventName + '"]');

        if (!target) {
          var availableSwaps = [].slice.call(document.querySelectorAll("[sse-swap]")).map(function(el) {
            return el.getAttribute("sse-swap");
          });
          console.log("No swap target found for event:", eventName, "available targets:", availableSwaps);
          return;
        }

        console.log("Found swap target for event:", eventName, "element:", target.id || target.className);

        // Parse the HTML fragment from the SSE data
        var temp = document.createElement("div");
        temp.innerHTML = detail.data;
        var newContent = temp.firstElementChild || temp;

        if (!newContent) {
          console.error("Failed to parse HTML fragment");
          return;
        }

        console.log("Performing outerHTML swap");

        // Perform direct DOM replacement
        target.outerHTML = newContent.outerHTML;

        console.log("Swap completed successfully");

      } catch (e) {
        console.error("Error processing SSE message:", e, e.stack);
      }
    }, false);

    // Manually create and connect EventSource for our custom SSE handling
    // Wait for body element to be available since this script runs in head before body is parsed
    function initEventSource() {
      var body = document.body;
      if (!body) {
        console.debug("Body element not ready yet, retrying in 100ms...");
        setTimeout(initEventSource, 100);
        return;
      }

      var sseUrl = body.getAttribute('data-sse-url');

      if (!sseUrl) {
        console.log("No data-sse-url found on body element");
        return;
      }

      console.log("Found SSE URL:", sseUrl);
      // Create the EventSource with credentials
      var eventSource = new EventSource(sseUrl, { withCredentials: true });
      console.log("Created EventSource for:", sseUrl);

      // Handle 'indexProgress' events
      eventSource.addEventListener('indexProgress', function(event) {
        var detail = {
          data: event.data,
          lastEvent: 'indexProgress'
        };
        // Dispatch before event
        var beforeEvent = new CustomEvent('htmx:sseBeforeMessage', {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(beforeEvent);

        // Dispatch main event for our handler
        var messageEvent = new CustomEvent('htmx:sseMessage', {
          detail: detail,
          bubbles: true
        });
        document.dispatchEvent(messageEvent);
      });

      // Handle 'indexSummary' events
      eventSource.addEventListener('indexSummary', function(event) {
        var detail = {
          data: event.data,
          lastEvent: 'indexSummary'
        };
        // Dispatch before event
        var beforeEvent = new CustomEvent('htmx:sseBeforeMessage', {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(beforeEvent);

        // Dispatch main event for our handler
        var messageEvent = new CustomEvent('htmx:sseMessage', {
          detail: detail,
          bubbles: true
        });
        document.dispatchEvent(messageEvent);
      });

      eventSource.onerror = function(error) {
        console.error("EventSource error - readyState:", eventSource.readyState, "error:", error);
        if (eventSource.readyState === EventSource.CLOSED) {
          console.log("EventSource connection closed permanently");
        } else if (eventSource.readyState === EventSource.CONNECTING) {
          console.log("EventSource attempting to reconnect...");
        } else if (eventSource.readyState === EventSource.OPEN) {
          console.log("EventSource connection open but error occurred");
        }
      };
    }

    // Call initEventSource() to wait for body element and create EventSource
    initEventSource();
  }

  // Start initialization when script loads
  initSSEExtension();
})();
