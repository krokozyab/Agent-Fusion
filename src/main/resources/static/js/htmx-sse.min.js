/*
HTMX SSE Extension - Handles Server-Sent Events with out-of-band swaps
Completely bypasses HTMX's built-in SSE handler to prevent null reference errors
*/
(function() {
  'use strict';

  // Wait for HTMX to be available
  function initSSEExtension() {
    if (!window.htmx) {
      console.debug("HTMX not ready yet, retrying in 100ms...");
      setTimeout(initSSEExtension, 100);
      return;
    }

    console.log("HTMX SSE extension loaded and registered");

    var htmx = window.htmx;

    // Override HTMX's createEventSource to prevent it from trying to manage SSE
    // This stops HTMX's built-in SSE handler from interfering
    if (htmx.createEventSource) {
      var originalCreateEventSource = htmx.createEventSource;
      htmx.createEventSource = function(url) {
        console.log("HTMX tried to create EventSource for:", url, "- BLOCKING to prevent conflicts");
        // Return a dummy object that won't cause errors
        return {
          addEventListener: function() {},
          removeEventListener: function() {},
          close: function() {}
        };
      };
    }

    // Also override the trigger function to catch null targets early
    if (htmx.trigger) {
      var originalTrigger = htmx.trigger;
      htmx.trigger = function(elt, event, detail) {
        if (!elt) {
          console.warn("HTMX trigger called with null element for event:", event, "- BLOCKING to prevent error");
          return;
        }
        return originalTrigger.call(htmx, elt, event, detail);
      };
    }

    // Register this as an HTMX extension (for naming purposes)
    htmx.defineExtension('sse', {
      init: function(api) {
        console.log("SSE extension initialized by HTMX");
      }
    });

    // Global handler for all HTMX SSE events - intercept and prevent HTMX processing
    document.addEventListener("htmx:sseBeforeMessage", function(evt) {
      console.log("htmx:sseBeforeMessage intercepted - lastEvent:", evt.detail ? evt.detail.lastEvent : "unknown");
      // Stop HTMX from processing this
      evt.preventDefault();
      evt.stopImmediatePropagation();
    }, true); // Capture phase to intercept early

    // Our custom handler for SSE messages - we do the DOM swaps ourselves
    document.addEventListener("htmx:sseMessage", function(evt) {
      try {
        if (!evt.detail) {
          console.log("No detail in SSE message");
          return;
        }

        var detail = evt.detail;
        var eventName = detail.lastEvent || detail.eventType;

        console.log("SSE Message received - lastEvent:", detail.lastEvent, "eventType:", detail.eventType, "data length:", detail.data ? detail.data.length : 0);

        if (!eventName) {
          console.log("No event name found in SSE message");
          return;
        }

        // Find target element with matching sse-swap attribute
        var target = document.querySelector('[sse-swap="' + eventName + '"]');

        if (!target) {
          var availableSwaps = [].slice.call(document.querySelectorAll("[sse-swap]")).map(function(el) {
            return el.getAttribute("sse-swap");
          });
          console.log("No swap target found for event:", eventName, "available targets:", availableSwaps);
          return;
        }

        console.log("Found swap target for event:", eventName, "element:", target.id || target.className);

        // Parse the HTML fragment from the SSE data
        var temp = document.createElement("div");
        temp.innerHTML = detail.data;
        var newContent = temp.firstElementChild || temp;

        if (!newContent) {
          console.error("Failed to parse HTML fragment");
          return;
        }

        console.log("Performing outerHTML swap");

        // Perform direct DOM replacement
        target.outerHTML = newContent.outerHTML;

        console.log("Swap completed successfully");

      } catch (e) {
        console.error("Error processing SSE message:", e, e.stack);
      }
    }, false);

    // Manually create and connect EventSource for our custom SSE handling
    // Wait for body element to be available since this script runs in head before body is parsed
    function initEventSource() {
      var body = document.body;
      if (!body) {
        console.debug("Body element not ready yet, retrying in 100ms...");
        setTimeout(initEventSource, 100);
        return;
      }

      var sseUrl = body.getAttribute('data-sse-url');

      if (!sseUrl) {
        console.log("No data-sse-url found on body element");
        return;
      }

      console.log("Found SSE URL:", sseUrl);
      // Create the EventSource with credentials
      var eventSource = new EventSource(sseUrl, { withCredentials: true });
      console.log("Created EventSource for:", sseUrl);

      // Handle 'indexProgress' events
      eventSource.addEventListener('indexProgress', function(event) {
        var detail = {
          data: event.data,
          lastEvent: 'indexProgress'
        };
        // Dispatch before event
        var beforeEvent = new CustomEvent('htmx:sseBeforeMessage', {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(beforeEvent);

        // Dispatch main event for our handler
        var messageEvent = new CustomEvent('htmx:sseMessage', {
          detail: detail,
          bubbles: true
        });
        document.dispatchEvent(messageEvent);
      });

      // Handle 'indexSummary' events
      eventSource.addEventListener('indexSummary', function(event) {
        var detail = {
          data: event.data,
          lastEvent: 'indexSummary'
        };
        // Dispatch before event
        var beforeEvent = new CustomEvent('htmx:sseBeforeMessage', {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(beforeEvent);

        // Dispatch main event for our handler
        var messageEvent = new CustomEvent('htmx:sseMessage', {
          detail: detail,
          bubbles: true
        });
        document.dispatchEvent(messageEvent);
      });

      eventSource.onerror = function(error) {
        console.error("EventSource error:", error);
        if (eventSource.readyState === EventSource.CLOSED) {
          console.log("EventSource connection closed");
        }
      };
    }

    // Call initEventSource() to wait for body element and create EventSource
    initEventSource();
  }

  // Start initialization when script loads
  initSSEExtension();
})();
